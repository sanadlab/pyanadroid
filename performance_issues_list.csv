Issue;Android-Specific;Chimera;Adoctor;DAAP;Lint;PMD;Ecoandroid;Leafactor;Paprika;Droidlens;xAL;Detectable in Kotlin;Explanation;Sample;Expected fix;File Extensions;
SlowForLoop;Yes;;✅;✅;;;;;;;;;The standard version of the for loop is slower than the for-each loop. Therefore, Android developers should always use an enhanced version of the loop to improve the efﬁciency of the app.;;Replace standard for loops with enhanced for-each loops whenever possible. This improves performance and efficiency by avoiding unnecessary index calculations and direct array manipulations.;*.java, *.kt;
DrawAllocation;Yes;;;;✅;;;✅;✅;✅;;✅;You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations. The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation. Some methods allocate memory on your behalf (such as Bitmap.create), and these should be handled in the same way.;https://googlesamples.github.io/android-custom-lint-rules/checks/DrawAllocation.md.html;Avoid allocating new objects during drawing or layout operations (e.g onDraw methods). Instead, preallocate objects before drawing and reuse them. Methods like Bitmap.create() should also follow this approach to prevent frequent garbage collection and UI lag. Examples of such methods: android.view.View, android.view.ViewGroup.dispatchDraw, android.graphics.drawable.Drawable.draw, android.view.View.invalidate, android.view.View.postInvalidate, android.view.View.onDrawForeground, android.view.View.onMeasure, android.view.ViewGroup.onLayout, android.view.View.layout, android.view.View.onSizeChanged, ;*.java, *.kt;
Recycle;Yes;;;;✅;;;✅;;;;✅;Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a recycle() call) after use. This lint check looks for missing recycle() calls.;https://googlesamples.github.io/android-custom-lint-rules/checks/Recycle.md.html;Always call .recycle() on resources such as TypedArray, VelocityTracker, and others after use. This prevents memory leaks and ensures efficient resource management.;*.java, *.kt;
WakeLock;Yes;;✅;✅;✅;;✅;✅;;;;✅;hich reduces battery life. There are several causes of this, such as releasing the wake lock in onDestroy() instead of in onPause(), failing to call release() in all possible code paths after an acquire(), and so on.NOTE: If you are using the lock just to keep the screen on, you should strongly consider using FLAG_KEEP_SCREEN_ON instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. ;https://googlesamples.github.io/android-custom-lint-rules/checks/Wakelock.md.html;Ensure wake locks are released properly in onPause() instead of onDestroy(), and always include a release() call in all possible code paths. If keeping the screen on is the only goal, use FLAG_KEEP_SCREEN_ON instead, as it is managed automatically by the platform.;*.java, *.kt;
WakelockTimeout;Yes;;;;✅;;;;;;;✅;Wakelocks have two acquire methods: one with a timeout, and one without. You should generally always use the one with a timeout. A typical timeout is 10 minutes. If the task takes longer than it is critical that it happens (i.e. can't use JobScheduler) then maybe they should consider a foreground service instead (which is a stronger run guarantee and lets the user know something long/important is happening).;https://googlesamples.github.io/android-custom-lint-rules/checks/WakelockTimeout.md.html;Always use the wake lock acquire method that includes a timeout. A typical timeout is 10 minutes. If longer execution is needed, consider using a foreground service instead, which ensures the task completes while informing the user.;*.java, *.kt;
ViewHolder;Yes;;;;✅;;;✅;;;;✅;"When implementing a view Adapter, you should avoid unconditionally inflating a new layout; if an available item is passed in for reuse, you should try to use that one instead. This helps make for example ListView scrolling much smoother.";https://googlesamples.github.io/android-custom-lint-rules/checks/ViewHolder.md.html;: In RecyclerView.Adapter and similar adapters, reuse existing views instead of inflating new ones each time. Implement the ViewHolder pattern to improve scrolling performance and reduce unnecessary object creation.;*.java, *.kt;
ObsoleteLayoutParam;Yes;;;;✅;;;✅;;;;✅;The given layout_param is not defined for the given layout, meaning it has no effect. This usually happens when you change the parent layout or move view code around without updating the layout params. This will cause useless attribute processing at runtime, and is misleading for others reading the layout so the parameter should be removed.;https://googlesamples.github.io/android-custom-lint-rules/checks/ObsoleteLayoutParam.md.html;Edit the XML file and delete the obsolete parameter that has no effect.;*.xml;
BLOBClass;No;;;;;;;;✅;✅;;;Blob Class (BLOB) - OO: A Blob class, also know as God class, is a class with a large number of attributes and/or methods [17]. The Blob class handles a lot of responsibilities compared to other classes. Attributes and methods of this class are related to different concepts and processes, implying a very low cohesion. Blob classes are also often associated with numerous data classes. Blob classes are hard to maintain and increase the difﬁculty to modify the software. In PAPRIKA, classes are identiﬁed as Blob classes whenever the metrics numbers_of_attributes, number_of_methods and lack_of_cohesion_in_methods are very high.;; Refactor the large class by splitting it into multiple smaller, cohesive classes with clear responsibilities. Use Single Responsibility Principle (SRP) to ensure each class focuses on a single task. Extract related attributes and methods into separate, more maintainable classes.;*.java, *.kt;
SwissArmyKnife;No;;;;;;;;✅;✅;;;A Swiss army knife is a class with numerous interface signatures, resulting in a very complex class interface designed to handle a wide diversity obstractions. This type of class is hard to understand and to maintain because of the resulting complexity. A SAK is detected by Paprika when a class implements a large number of interfaces.;;Reduce the number of interfaces a class implements. If multiple interfaces are needed, consider breaking them into smaller, more specialized interfaces (Interface Segregation Principle). This makes the class easier to understand and maintain.;*.java, *.kt;
Longmethod;No;;;;;;;;✅;✅;;;Long methods are implemented with much more lines of code than other methods. They are often very complex, and thus hard to understand and main-tain. These methods can be split into smaller methodstofixtheproblem[21]. Paprika iden- tifies a long method when the number of instructions for one method is very high.;;Break long methods into multiple smaller methods, each performing a specific task. Use method extraction to improve readability and maintainability. Follow the Single Responsibility Principle (SRP) to avoid excessive complexity in a single method.;*.java, *.kt;
ComplexClass;No;;;;;;;;✅;✅;;;A complex class is a class containing complex methods. Again, these classes are hard to understandand maintain and need to be refactored [21]. The class complexity is calculated by summing the internal methods complexities. The complexity of a method can be calculated using McCabe’s Cyclomatic Complexity [27].;;educe the internal complexity of the class by simplifying complex methods. Use Cyclomatic Complexity (McCabe's metric) as a guide to refactor methods into smaller, well-defined methods. Apply design patterns like Strategy or Factory to delegate responsibilities.;*.java, *.kt;
InternalGetterSetter;No;✅;✅;✅;✅;;;;✅;✅;;n/a?;"On Android, fields should be accessed directly within a class to increase performance. The usage of an internal getter or a setter con- verts into a virtual invoke, which makes the operation three times slower than a direct access . NOTE: As of Android 2.3 (Gingerbread), this optimization is performed automatically by Dalvik, so there is no need to change your code; this is only relevant if you are targeting older versions of Android.";;This issue is obsolete for Android versions 2.3 (Gingerbread) and above since the Dalvik runtime optimizes direct field access. If targeting very old versions, access fields directly within the class instead of using getters and setters to improve performance.;*.java, *.kt;
MemberIgnoringMethod;No;✅;✅;✅;;;;;✅;✅;;;on Android, when a method does not access an object attribute, it is recommended to use a static method. The static method invocations are about 15%–20% faster than a dynamic invocation;;Convert instance methods that do not access instance fields into static methods. Static methods are more efficient as they do not require an object instance for invocation, improving performance by 15%–20%.;*.java, *.kt;
NoLowMemoryResolver;Yes;;✅;✅;;;;;✅;✅;✅;✅;When the Android system is running low on memory, the system calls the method onLowMemory() of running activities, which are supposed to trim their memory usage. If this method is not implemented by the activity, the Android system kills the process in order to free memory, and can cause an abnormal termination of programs ;;mplement the onLowMemory() and onTrimMemory(int level) methods in Activity and Application classes to handle low-memory situations. Free unnecessary resources, clear caches, and optimize memory usage to prevent unexpected app termination.;*.java, *.kt;
LeakingInnerClass;No;;✅;✅;✅;;;;✅;✅;;;In Java, non-static inner and anonymous classes are holding a reference to the outer class, whereas static inner classes are not. This could provoke a memory leak in Android systems;;Convert non-static inner classes to static inner classes or use WeakReference to avoid memory leaks. If an inner class requires access to the outer class, use a WeakReference<OuterClass> instead of a direct reference.;*.java, *.kt;
UnsuitedLRUCacheSize;Yes;;;;;;;;;✅;;;in Android, a cache can be used to store frequently used objects with the Least Recently Used (LRU) API. The code smell occurs when the LRU is initialized without checking the available memory via the getMemoryClass() method. The available memory may vary considerably according to the device so it is necessary to adapt the cache size to the available memory;;When initializing an LRUCache, set its size dynamically based on available memory using ActivityManager.getMemoryClass(). This ensures the cache size adapts to different device specifications, preventing excessive memory usage.;*.java, *.kt;
HashmapUsage;Yes;✅;✅;✅;✅;;;;✅;✅;;✅;the usage of HashMap is inadvisable when managing small sets in Android. Using HashMaps entails the auto-boxing process where primitive types are converted into generic objects. The issue is that generic objects are much larger than primitive types, 16 and 4 bytes, respectively. Therefore, the framework recommends using the SparseArray data structure that is more memory-eﬃcient;;Replace HashMap<Integer, Object> with SparseArray<T>, SparseIntArray, or SparseBooleanArray when working with primitive integer keys. This avoids auto-boxing and significantly reduces memory consumption.;*.java, *.kt;
Overdraw;yes;;;;✅;;;;;;;;"If you set a background drawable on a root view, then you should use a custom theme where the theme background is null. Otherwise, the theme background will be painted first, only to have your custom background completely cover it; this is called “overdraw”. NOTE: This detector relies on figuring out which layouts are associated with which activities based on scanning the Java code, and it's currently doing that using an inexact pattern matching algorithm. Therefore, it can incorrectly conclude which activity the layout is associated with and then wrongly complain that a background-theme is hidden. If you want your custom background on multiple pages, then you should consider making a custom theme with your custom background and just using that theme instead of a root element background. Of course it's possible that your custom drawable is translucent and you want it to be mixed with the background. However, you will get better performance if you pre-mix the background with your drawable and use that resulting image or color as a custom theme background instead.";;Remove unnecessary background layers in XML or Java code. If setting a custom background on a root view, use a theme with a transparent background instead of layering multiple backgrounds. Pre-mix translucent backgrounds with images for better performance.;*.xml;
UIOverdraw;Yes;;;✅;✅;;;;✅;✅;;✅;a UI Overdraw is a situation where a pixel of the screen is drawn many times in the same frame. This happens when the UI design consists of unneeded overlapping layers, e.g., hidden backgrounds. To avoid such situations, the canvas.quickreject() API should be used to define the view boundaries that are drawable;;"Optimize layout design by removing overlapping UI layers. Use canvas.quickReject() to define drawable boundaries and prevent unnecessary rendering. Enable ""Show GPU Overdraw"" in Developer Options to detect excessive overdraw.";*.java, *.kt;
InvalidatewithoutRect;Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when rect to be redrawn is not specified while invalidating the view;; When calling invalidate(), specify a bounding rectangle (invalidate(Rect) or invalidate(left, top, right, bottom)) to redraw only the affected area instead of the entire view, improving performance.;*.java, *.kt;
Unsupported Hardware Acceleration (UHA),;Yes;;;;;;;;✅;✅;✅;;On Android, most of the drawing operations are executed in the GPU. Rare drawing operations that are executed in the CPU, e.g., drawPath method in android.graphics.Canvas, should be avoided to reduce CPU load;;Avoid CPU-bound drawing operations like Canvas.drawPath() in performance-critical areas. Instead, use hardware-accelerated alternatives like ShapeDrawable, VectorDrawable, or OpenGL ES for complex graphics.;*.java, *.kt;
Heavy AsyncTask (HAS);Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when heavy operations are carried out inside an Async Task. Heavy operation is considered to be any operation that has computational complexity of greater than 10 (McConnel S. Code Complete).;;Offload heavy computations (e.g., complex loops, large database operations) from AsyncTask.doInBackground() to background worker threads using Executors, Coroutines, or WorkManager.;*.java, *.kt;
Heavy Service Start (HSS);Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when heavy operations are carried out inside a Service;;void running long or computationally expensive tasks inside Service. Use JobScheduler, WorkManager, or foreground services for long-running operations.;*.java, *.kt;
Heavy Broadcast Receiver (HBR);Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when heavy operations are carried out inside a onRecieve() function of Broadcast Receiver;;Keep onReceive() lightweight. Offload heavy processing to a background thread using IntentService, WorkManager, or JobIntentService. Avoid long-running computations in broadcast receivers to prevent ANRs.;*.java, *.kt;
Bitmap Format Usage (BFU);Yes;;;;;;;;✅;;✅(divergent);;Bitmap Format Usage is a code smell that arises when images are represented as Bitmaps which is memory intensive function.;;ptimize bitmap usage by using vector drawables (VectorDrawable) or WebP format instead of Bitmap. When using bitmaps, compress them using BitmapFactory.Options.inSampleSize and avoid loading full-resolution images unnecessarily.;*.java, *.kt;
UnclosedCloseable;Yes;;✅;✅;;;;;;;;;A class that implements the java.io.Closeable interface is supposed to invoke the close method to release resources that an object is holding.;;Always close resources (like files, streams, or database cursors) by calling close() in a finally block or using Java’s try-with-resources;*.java, *.kt;
CameraLeak;Yes;✅;;;;;✅;;;;✅;✅;android.hardware.Camera - Keeping the camera active without using it;;Always release the camera when it is no longer needed by calling camera.release() in onPause() or onDestroy(). Consider using Camera2API, which provides a more lifecycle-aware approach.;*.java, *.kt;
SensorLeak;Yes;✅;;;;;;;;;;;android.hardware.SensorManager - Keeping the sensor active without using it;;Unregister sensors when they are no longer needed by calling sensorManager.unregisterListener(sensorEventListener) in onPause() or onDestroy().;*.java, *.kt;
MediaLeak;Yes;✅;;;;;✅;;;;✅;✅;Keeping the media recorder active without using it;;Always stop and release the MediaRecorder when finished recording using stop() and release() methods;*.java, *.kt;
LeakingThread;;;✅;✅;✅?;;;;;;✅;✅;In Android programming a thread is a garbage collector (GC) root. The GC does not collect the root bjects and, therefore, if a thread is not adequately stopped it can remain in memory for all the execution of the application, causing an abuse of the memory of the app. If an Activity starts a thread and does not stop it this is considered a design ﬂaw [18]. ADOCTOR detects this smell if a method of an Activity class starts a thread without stopping it through the stop method.;;Ensure that threads started within an Activity are properly stopped when the activity is destroyed. Use Thread.interrupt() or switch to HandlerThread, ExecutorService, or Kotlin Coroutines for better lifecycle management.;*.java, *.kt;
LeakingHandler;;;;✅?;✅;;;;;;✅;✅;"Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.";https://googlesamples.github.io/android-custom-lint-rules/checks/HandlerLeak.md.html;Declare handlers as static inner classes to prevent memory leaks. Use a WeakReference to reference the outer class;*.java, *.kt;
DataTransmissionWithoutCompression;No;;✅;;;;✅;;;;✅;✅;The smell arises when a method transmits a ﬁle over a network infrastructure without compressing it, causing an overhead of communication [18]. ADOCTOR detects the smell if a method performs an Http request involving an instance of the class File without using a compression library such as ZLIB2 or the APACHE HTTP CLIENT3.;;Compress files before transmitting over a network using Zlib, Gzip, or Apache HttpClient to reduce bandwidth usage;*.java, *.kt;
VacuousBackgroundService;Yes;;;;;;;;;;✅* many false positives?;✅;refers to an energy bug that arises when a service consumes resources in the background. Hence, a service should be stopped before the application goes to background in onStop method;;Stop services when the app goes into the background by calling stopSelf() in onStop(). Prefer JobScheduler, WorkManager, or Foreground Services only when necessary.;*.java, *.kt;
LifecycleContainment;Yes;;;;;;;;;;✅;✅;refers to a code smell that arises when a listener is registered but not unregistered from activity;;Always unregister listeners in onPause() or onDestroy();*.java, *.kt;
EarlyResourceBinding;Yes;;;;;;;;;;✅;✅;refers to code smell that arises when heavy resources such as database connections, Camera, Media Player and Location Manager are initialized before they need to be used;;Delay initializing heavy resources (e.g., Camera, MediaPlayer, LocationManager, Database) until they are actually needed instead of initializing them early in onCreate().;*.java, *.kt;
ImmortalityBug;Yes;;;;;;;;;;✅* (does not check for foreground service);✅;refers to an energy bug that arises when an application re-spawns when it is not opened by the user. To detect this issues, calls to start a foreground operation like activity are removed from background operations like Services;; Prevent apps from restarting unnecessarily by removing auto-restart logic in background services. Avoid using START_STICKY unless necessary and ensure proper foreground service management.;*.java, *.kt;
RigidAlarmManager;Yes;;✅;✅;;;;;;;;;. The AlarmManager class allows to execute operations at speciﬁc moments. Obviously, an Alarm Manager-triggered operation wakes- up the phone, possibly threatening the energy and memory efﬁciency of the app. It is recommended to use the AlarmManager.setInexactRepeating method, which ensures that the system is able to bundle several updates together [18]. Therefore, a code smell is identiﬁed by our detector if a class using an instance of AlarmManager does not deﬁne the method setInexactRepeating.;;Use setInexactRepeating() instead of setRepeating() to allow Android to batch operations and reduce power usage;*.java, *.kt;
InefficientSQLQuery;Yes;;✅;;;;;;;;;;In Android, the use of a SQL query is discouraged as it introduces overhead, while other solutions should be preferred (e.g., using webservices) [18]. If a method deﬁnes a JDBC connection and sends an SQL query to a remote server, the smell is identiﬁed.;; Avoid direct SQL queries when possible. Prefer Room Database, SQLite with indexing, or Web services instead of raw SQL queries to minimize performance overhead.;*.java, *.kt;
DebuggableRelease;Yes;;✅;✅;;;;;;;;;In Android, the attribute android:debuggable of the AndroidManifest ﬁle is set during the development for debugging an app. Leaving the attribute true when the app is released is a major security threat since every external app can have full access to the source code. In this case, the detector simply parses the AndroidManifest ﬁle looking for the android:debuggable properties. If it is explicitly set to true, the smell is detected.;;"Ensure android:debuggable=""false"" in the AndroidManifest.xml file for release builds.";*.xml;
InefficientDataFormatAndParser;Yes;;✅;✅;;;;;;;;;When analyzing XML or JSON ﬁles, the use of TreeParser slows down the app, and thus it should be avoided and replaced with other more efﬁcient parsers (e.g.,StreamParser) [18]. In this case, ADOCTOR identiﬁes the smell by evaluating whether a method uses the TreeParser class.;; Replace Tree-based parsers (e.g., DocumentBuilder for XML, JSONObject for JSON) with stream-based parsers (XmlPullParser, JsonReader) for better performance.;*.java, *.kt;
MemoizationChance;No;✅;;;;;;;;;;;Methods that work as simple functions are good targets to exploit memoization for performance enhancement;;Implement memoization to cache function results, avoiding redundant computations;*.java, *.kt;
DynamicWaitTime;No;;;;;;✅;;;;;;This inspection identifies cases where the wait time between attempts to access a resource is constant. In those cases, the constant is changed to a dynamic value that grows with the number of attempts. It also considers the values used to put threads to sleep. <br>;;Implement exponential backoff instead of using constant wait times;*.java, *.kt;
InfoWarningFCM;Yes;;;;;;✅;;;;;; This inspection identifies cases where the method android.app.AlarmManager.setRepeating is used and adds a <i>TODO</i> to the source code to remind developers that it would be preferable to implement push notifications, rather than using a possible polling system. <br>;;Replace AlarmManager.setRepeating() (polling) with Firebase Cloud Messaging (FCM) for push notifications;*.java, *.kt;
PassiveProviderLocation;;;;;;;✅;;;;;; This inspection switches to a <i>LocationManager.PASSIVE_PROVIDER</i> when invoking the method <i>requestLocationUpdates</i> from the class <i>android.location.LocationManager;; Use LocationManager.PASSIVE_PROVIDER when location updates are needed but don’t require GPS;*.java, *.kt;
SSLSessionCaching;;;;;;;✅;;;;;;    This inspection applies the energy pattern https://tqrg.github.io/energy-patterns/#/patterns/Cache by attempting to increase the cache size of an SSL Session.    It identifies cases where the cache size is not already set to a specific value and removes any default ;;Increase SSL session cache size for better performance;*.java, *.kt;
URLCaching;;;;;;;✅;;;;;;This inspection identifies cases where no changes occur since the last update from an URL connection. It adds a <i>TODO</i> to the source code to remind developers that there is an opportunity to apply the energy pattern https://tqrg.github.io/energy-patterns/#/patterns/Cache;;Implement HTTP caching using HttpURLConnection;*.java, *.kt;
CheckLayoutSize;Yes;;;;;;✅;;;;;;  This inspection ensures that a layout is not drawn when its measurements are zero.   This is specific to the usage of the class android.view.SurfaceHolder.;;Ensure layouts are not drawn if their measurements are zero when using android.view.SurfaceHolder;*.java, *.kt;
CheckMetadata;;;;;;;✅;;;;;; This inspection identifies cases where a simple cache mechanism can be added in the method onReceive of subclasses of android.content.BroadcastReceiver. In those cases, the source code is refactored so that changes in the    values retrieved from the intent parameter are checked before processing the information received.<br>;; Implement a simple caching mechanism in onReceive() of BroadcastReceiver to avoid redundant processing.;*.java, *.kt;
CheckNetwork;No;;;;;;✅;;;;;;  This inspection identifies cases where a network connection exists before processing a request. This is only activated when subclasses of android.app.IntentService are used. <br>;; Ensure network availability before processing requests in IntentService.;*.java, *.kt;
DirtyRendering;Yes;;;;;;✅;;;;;;This inspection switches the rendering mode to <i>GLSurfaceView.RENDERMODE_WHEN_DIRTY;;Switch to lazy rendering using GLSurfaceView.RENDERMODE_WHEN_DIRTY.;*.java, *.kt;
ExcessiveLoopCallsDetector;No;✅;;;;;;;;;;;Calling methods inside loops, either in the loop condition or in the body, is  usually a good optimization target;;Avoid method calls inside loops when possible by precomputing values outside the loop.;*.java, *.kt;
NestedWeight;Yes;;;✅;✅;;;;;;;✅;Layout weights require a widget to be measured twice. When a LinearLayout with non-zero weights is nested inside another LinearLayout with non-zero weights, then the number of measurements increase exponentially.;https://googlesamples.github.io/android-custom-lint-rules/checks/NestedWeights.md.html;Avoid nested LinearLayouts with weights by using ConstraintLayout or RelativeLayout instead.;*.xml;
ConfigChanges;;;;✅;;;;;;;;;In Android applications, it is considered a code smell if attribute android:configChanges is defined in Manifest file. This phenomenon leads to memory leaks;;Avoid handling android:configChanges in the AndroidManifest.xml and instead handle config changes properly in onSaveInstanceState().;*.xml;
DroppedData;No;;;✅;;;;;;;;;on Android applications, the data filled by user in any Activity or fragment may be lost if the focused screen is interrupted. Data should be saved and restored using overridable methods on SaveInstanceState and on RestoreInstanceState;; Preserve user data using onSaveInstanceState() and onRestoreInstanceState().;*.java, *.kt;
CollectionOfBitmaps;Yes;;;✅;;;;;;;;;The collection of bitmaps is a resource intensive process and should be avoided;;"Avoid loading multiple bitmaps in memory; use bitmap pooling or LruCache.";*.java, *.kt;
CollectionOfViews;Yes;;;✅;;;;;;;;;The collection of views is a resource intensive process in Android applications and should be avoided;;Do not store views in collections;*.java, *.kt;
StaticBitmap;Yes;;;✅;✅;;;;;;;✅;Bitmaps are heavy objects and should be dealt with proper case otherwise it can lead to memory leaks.;;"Do not store bitmaps in static fields; use caching mechanisms like LruCache instead.";*.java, *.kt;
StaticContext;Yes;;;✅;✅;;;;;;;✅;In Android applications, declaring field of type Context leads to memory leak as it is never col-lected by garbage collector of JVM;;In Android applications, declaring field of type Context leads to memory leak as it is never colllected by garbage collector of JVM;*.java, *.kt;
StaticView;Yes;;;✅;✅;;;;;;;✅;Holding static reference of any view type object is a resource (memory) intensive process;;Avoid keeping static references to View objects to prevent memory leaks.;*.java, *.kt;
StaticFieldLeak;No;;;;✅;;;;;;;✅;A static field will leak contexts. Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a Fragment or Activity, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected. Similarly, direct field references to activities and fragments from these longer running instances can cause leaks. ViewModel classes should never point to Views or non-application Contexts.;https://googlesamples.github.io/android-custom-lint-rules/checks/StaticFieldLeak.md.html;Avoid static references to Activities, Fragments, and Views. If needed, use WeakReference.;*.java, *.kt;
AppendCharacterWithChar;No;;;;;✅;;;;;;;Avoid concatenating characters as strings in StringBuffer/StringBuilder.append methods.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#appendcharacterwithchar;"oid concatenating characters using StringBuffer.append() or StringBuilder.append() with characters. use instead: StringBuffer sb = new StringBuffer();sb.append('a');";*.java, *.kt;
AvoidArrayLoops;No;;;;;✅;;;;;;;Instead of manually copying data between two arrays, use the more efficient Arrays.copyOf or System.arraycopy method instead.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidarrayloops;Use System.arraycopy() or Arrays.copyOf() instead of looping through arrays.;*.java, *.kt;
AvoidCalendarDateCreation;No;;;;;✅;;;;;;;: java.util.Calendar is a heavyweight object and expensive to create. It should only be used, if calendar calculations are needed.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidcalendardatecreation;Use new Date(), Java 8+ java.time.LocalDateTime.now() or ZonedDateTime.now().;*.java, *.kt;
AvoidFileStream;No;;;;;✅;;;;;;;The FileInputStream and FileOutputStream classes contains a finalizer method which will cause garbage collection pauses. See JDK-8080225 for details. The FileReader and FileWriter constructors instantiate FileInputStream and FileOutputStream, again causing garbage collection issues while finalizer methods are called. Use Files.newInputStream(Paths.get(fileName)) instead of new FileInputStream(fileName). Use Files.newOutputStream(Paths.get(fileName)) instead of new FileOutputStream(fileName). Use Files.newBufferedReader(Paths.get(fileName)) instead of new FileReader(fileName). Use Files.newBufferedWriter(Paths.get(fileName)) instead of new FileWriter(fileName). Please note, that the java.nio API does not throw a FileNotFoundException anymore, instead it throws a NoSuchFileException. If your code dealt explicitly with a FileNotFoundException, then this needs to be adjusted. Both exceptions are subclasses of IOException, so catching that one covers both.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Use Files.newInputStream(Paths.get(fileName)) instead of new FileInputStream(fileName). Use Files.newOutputStream(Paths.get(fileName)) instead of new FileOutputStream(fileName). Use Files.newBufferedReader(Paths.get(fileName)) instead of new FileReader(fileName). Use Files.newBufferedWriter(Paths.get(fileName)) instead of new FileWriter(fileName). ;*.java, *.kt;
AvoidInstantiatingObjectsInLoops;No;;;;;✅;;;;;;;New objects created within loops should be checked to see if they can created outside them and reused.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Avoid creating new objects inside loops if they can be reused outside the loop.;*.java, *.kt;
BigIntegerInstantiation;No;;;;;✅;;;;;;;Don’t create instances of already existing BigInteger (BigInteger.ZERO, BigInteger.ONE), for Java 1.5 onwards, BigInteger.TEN and BigDecimal (BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN) and for Java 9 onwards BigInteger.TWO.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Use existing BigInteger constants (BigInteger.ZERO, BigInteger.ONE, etc.) instead of instantiating new BigInteger objects.;*.java, *.kt;
ConsecutiveAppendsShouldReuse;No;;;;;✅;;;;;;;Consecutive calls to StringBuffer/StringBuilder .append should be chained, reusing the target object. This can improve the performance by producing a smaller bytecode, reducing overhead and improving inlining.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Chain consecutive StringBuilder.append() or StringBuffer.append() calls to reduce bytecode size and improve performance.;*.java, *.kt;
ConsecutiveLiteralAppends;No;;;;;✅;;;;;;;onsecutively calling StringBuffer/StringBuilder.append(…) with literals should be avoided.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid appending literals consecutively in StringBuilder. Instead, append once or use string concatenation if necessary.;*.java, *.kt;
InefficientEmptyStringCheck;No;;;;;✅;;;;;;;String.trim().length() == 0 (or String.trim().isEmpty() for the same reason) is an inefficient way to check if a String is really blank,;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use String.isEmpty() or String.trim().isEmpty() instead of String.trim().length() == 0.;*.java, *.kt;
InefficientStringBuffering;No;;;;;✅;;;;;;;Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.;*.java, *.kt;
InsufficientStringBufferDeclaration;No;;;;;✅;;;;;;;Failing to pre-size a StringBuffer or StringBuilder properly could cause it to re-size many times during runtime.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Pre-size the StringBuffer or StringBuilder when the expected size is known.;*.java, *.kt;
OptimizableToArrayCall;No;;;;;✅;;;;;;;Calls to a collection’s toArray(E[]) method should specify a target array of zero size. This allows the JVM to optimize the memory allocation and copying as much as possible.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;When using toArray(), specify a zero-length array as an argument to allow for optimized memory allocation.;*.java, *.kt;
RedundantFieldInitializer;No;;;;;✅;;;;;;;Java will initialize fields with known default values so any explicit initialization of those same defaults is redundant and results in a larger class file (approximately three additional bytecode instructions per field).;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Remove redundant field initializations where default values are already provided by Java.;*.java, *.kt;
StringInstantiation;No;;;;;✅;;;;;;;"Avoid instantiating String objects; this is usually unnecessary since they are immutable and can be safely shared.";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"Avoid instantiating String objects; this is usually unnecessary since they are immutable and canbe safely shared.";*.java, *.kt;
StringToString;No;;;;;✅;;;;;;;"Avoid calling toString() on objects already known to be string instances; this is unnecessary.";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid instantiating new String objects when not necessary. Use string literals directly.;*.java, *.kt;
TooFewBranchesForSwitch;No;;;;;✅;;;;;;;Switch statements are intended to be used to support complex branching behaviour. Using a switch for only a few cases is ill-advised, since switches are not as easy to understand as if-else statements. In these cases use the if-else statement to increase code readability.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;If a switch statement has too few cases, consider using an if-else statement for clarity and performance.;*.java, *.kt;
UseArrayListInsteadOfVector;No;;;;;✅;;;;;;;ArrayList is a much better Collection implementation than Vector if thread-safe operation is not required.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html; Use ArrayList instead of Vector for non-thread-safe collection needs as ArrayList is more efficient.;*.java, *.kt;
UseArraysAsList;No;;;;;✅;;;;;;;The java.util.Arrays class has a asList() method that should be used when you want to create a new List from an array of objects. It is faster than executing a loop to copy all the elements of the array one by one.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use Arrays.asList() to convert an array to a list, which is faster than manually iterating over the array.;*.java, *.kt;
UseIndexOfChar;No;;;;;✅;;;;;;;"Use String.indexOf(char) when checking for the index of a single character; it executes faster.";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"Use String.indexOf(char) when checking for the index of a single character; it executes faster. Avoid indexOf(""d"")";*.java, *.kt;
UseIOStreamsWithApacheCommonsFileItem;No;;;;;✅;;;;;;;Problem: Use of FileItem.get() and FileItem.getString() could exhaust memory since they load the entire file into memory.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid using FileItem.get() and FileItem.getString() for large files. Use IO streams for better memory efficiency.;*.java, *.kt;
UseStringBufferForStringAppends;No;;;;;✅;;;;;;;he use of the ‘+=’ operator for appending strings causes the JVM to create and use an internal StringBuffer. If a non-trivial number of these concatenations are being used then the explicit use of a StringBuilder or threadsafe StringBuffer is recommended to avoid this.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use StringBuffer or StringBuilder explicitly for string concatenations in loops to avoid creating too many intermediate objects.;*.java, *.kt;
UseStringBufferLength;No;;;;;✅;;;;;;;"Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("""") or StringBuffer.toString().length() == ";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("""") or StringBuffer.toString().length() ==";*.java, *.kt;
AddEmptyString;No;;;;;✅;;;;;;;The conversion of literals to strings by concatenating them with empty strings is inefficient. It is much better to use one of the type-specific toString() methods instead or String.valueOf().;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;The conversion of literals to strings by concatenating them with empty strings is inefficient. It is much better to use one of the type-specific toString() methods instead or String.valueOf().;*.java, *.kt;
UselessParent;Yes;;;;✅;;;;;;;✅;A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.;https://googlesamples.github.io/android-custom-lint-rules/checks/UselessParent.md.html;A layout that has no siblings, is not a ScrollView or root layout, and has no background can be removed. Its children can be directly placed into the parent layout for a more efficient and flatter hierarchy.;*.xml;
UselessLeaf;Yes;;;;✅;;;;;;;✅;A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.;https://googlesamples.github.io/android-custom-lint-rules/checks/UselessLeaf.md.html; A layout with no children or background can be removed to simplify the view hierarchy and improve performance.;*.xml;
AnimatorKeep;Yes;;;;✅;;;;;;;✅;When you use property animators, properties can be accessed via reflection. Those methods should be annotated with @Keep to ensure that during release builds, the methods are not potentially treated as unused and removed, or treated as internal only and get renamed to something shorter. This check will also flag other potential reflection problems it encounters, such as a missing property, wrong argument types, etc.;https://googlesamples.github.io/android-custom-lint-rules/checks/AnimatorKeep.md.html;When using property animators, annotate the methods with @Keep to prevent them from being removed or renamed during release builds. This ensures that reflection-based access to properties works correctly.;*.java, *.kt;
ObsoleteSdkInt;Yes;;;;✅;;;;;;;✅;This check flags version checks that are not necessary, because the minSdkVersion (or surrounding known API level) is already at least as high as the version checked for. Similarly, it also looks for resources in -vNN folders, such as values-v14 where the version qualifier is less than or equal to the minSdkVersion, where the contents should be merged into the best folder.;https://googlesamples.github.io/android-custom-lint-rules/checks/ObsoleteSdkInt.md.html;Remove unnecessary SDK version checks when the minSdkVersion is already sufficient. If version-specific resources are available (e.g., values-v14), merge them into the appropriate folders based on the minSdkVersion.;*.java, *.kt;
DuplicateDivider;Yes;;;;✅;;;;;;;✅;Older versions of the RecyclerView library did not include a divider decorator, but one was provided as a sample in the support demos. This divider class has been widely copy/pasted into various projects. In recent versions of the support library, the divider decorator is now included, so you can replace custom copies with the “built-in” version, android.support.v7.widget.DividerItemDecoration.;https://googlesamples.github.io/android-custom-lint-rules/checks/DuplicateDivider.md.html;Replace custom divider decorators with the built-in DividerItemDecoration from the RecyclerView library, as it provides an optimized implementation for adding dividers.;*.java, *.kt;
UseValueOf;Yes;;;;✅;✅;;;;;;✅;You should not call the constructor for wrapper classes directly, such asnew Integer(42). Instead, call the valueOf factory method, such as Integer.valueOf(42). This will typically use less memory because common integers such as 0 and 1 will share a single instance.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseValueOf.md.html;You should not call the constructor for wrapper classes directly, such asnew Integer(42). Instead, call the valueOf factory method, such as Integer.valueOf(42). This will typically use less memory because common integers such as 0 and 1 will share a single instance.;*.java, *.kt;
UnpackedNativeCode (obsolete);Yes;;;;✅;;;;;;;✅;"You can enable it by adding --enable UnpackedNativeCode This app loads native libraries using System.loadLibrary(). Consider adding android:extractNativeLibs=""false"" to the <application> tag in AndroidManifest.xml. Starting with Android 6.0, this will make installation faster, the app will take up less space on the device and updates will have smaller download sizes.";e;"If you're loading native libraries via System.loadLibrary(), consider setting android:extractNativeLibs=""false"" in the AndroidManifest.xml to make installations faster, reduce app size, and make updates smaller.";*.xml;
UnusedResources;Yes;;;;✅;;;;;;;✅;Unused resources make applications larger and slow down builds. The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead. You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true. ,;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedResources.md.html;emove unused resources from your project to reduce its size and speed up builds. Consider packaging resources used only in tests separately in a test source set. Example: Use lint.unused-resources.exclude-tests=true to exclude test resources from the check.;*.java, *.kt, *.xml;
UnusedIds;Yes;;;;✅;;;;;;;✅;This resource id definition appears not to be needed since it is not referenced from anywhere. Having id definitions, even if unused, is not necessarily a bad idea since they make working on layouts and menus easier, so there is not a strong reason to delete these. The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead. You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedIds.md.html;Remove unused resource IDs, but keep in mind that they can help in the future during development. However, if you're sure they're not needed, you can delete them for a cleaner codebase.;*.java, *.kt, *.xml;
InefficientWeight;Yes;;;;✅;;;;;;;✅;When only a single widget in a LinearLayout defines a weight, it is more efficient to assign a width/height of 0dp to it since it will absorb all the remaining space anyway. With a declared width/height of 0dp it does not have to measure its own size first.;https://googlesamples.github.io/android-custom-lint-rules/checks/InefficientWeight.md.html;If only one widget in a LinearLayout has a weight, you should assign it a width or height of 0dp to make layout calculations more efficient.;*.xml;
DisableBaselineAlignment;Yes;;;;✅;;;;;;;✅;When a LinearLayout is used to distribute the space proportionally between nested layouts, the baseline alignment property should be turned off to make the layout computation faster.;https://googlesamples.github.io/android-custom-lint-rules/checks/DisableBaselineAlignment.md.html;When using LinearLayout to distribute space, turn off the baseline alignment property to speed up layout computation.;*.xml;
MergeRootFrame;Yes;;;;✅;;;;;;;✅;If a <framelayout> is the root of a layout and does not provide background or padding etc, it can often be replaced with a <merge> tag which is slightly more efficient. Note that this depends on context, so make sure you understand how the <merge> tag works before proceeding.;https://googlesamples.github.io/android-custom-lint-rules/checks/MergeRootFrame.md.html;If a FrameLayout is the root layout and does not provide background, padding, etc., it can be replaced with a merge tag to improve efficiency.;*.xml;
DevModeObsolete;Yes;;;;✅;;;;;;;✅;In the past, our documentation recommended creating a dev product flavor with has a minSdkVersion of 21, in order to enable multidexing to speed up builds significantly during development. That workaround is no longer necessary, and it has some serious downsides, such as breaking API access checking (since the true minSdkVersion is no longer known). In recent versions of the IDE and the Gradle plugin, the IDE automatically passes the API level of the connected device used for deployment, and if that device is at least API 21, then multidexing is automatically turned on, meaning that you get the same speed benefits as the dev product flavor but without the downsides.;https://googlesamples.github.io/android-custom-lint-rules/checks/DevModeObsolete.md.html;The workaround of creating a dev product flavor with minSdkVersion 21 to enable multidexing is no longer necessary. Multidexing is now handled automatically if the connected device runs API 21 or higher. Simply ensure you're using the appropriate Gradle configuration without the dev flavor workaround.;*.gradle;
LifecycleAnnotationProcessorWithJava8;Yes;;;;✅;;;;;;;✅;"For faster incremental build, switch to the Lifecycle Java 8 API with these steps: First replace annotationProcessor ""androidx.lifecycle:lifecycle-compiler:*version*"" kapt ""androidx.lifecycle:lifecycle-compiler:*version*"" with implementation ""androidx.lifecycle:lifecycle-common-java8:*version*"" Then remove any OnLifecycleEvent annotations from Observer classes and make them implement the DefaultLifecycleObserver interface.";https://googlesamples.github.io/android-custom-lint-rules/checks/LifecycleAnnotationProcessorWithJava8.md.html;"For faster incremental builds, switch to the Lifecycle Java 8 API by replacing annotationProcessor ""androidx.lifecycle:lifecycle-compiler"" with implementation ""androidx.lifecycle:lifecycle-common-java8"". Also, remove any OnLifecycleEvent annotations and use DefaultLifecycleObserver.";*.java, *.kt;
AnnotationProcessorOnCompilePath;Yes;;;;✅;;;;;;;✅;This dependency is identified as an annotation processor. Consider adding it to the processor path using annotationProcessor instead of including it to the compile path.;https://googlesamples.github.io/android-custom-lint-rules/checks/AnnotationProcessorOnCompilePath.md.html; If an annotation processor is included in the compile classpath, move it to the annotationProcessor path instead to optimize the build process.;*.gradle;
LogConditional;Yes;;;;✅;;;;;;;✅;The BuildConfig class provides a constant, DEBUG, which indicates whether the code is being built in release mode or in debug mode. In release mode, you typically want to strip out all the logging calls. Since the compiler will automatically remove all code which is inside a if (false) check, surrounding your logging calls with a check for BuildConfig.DEBUG is a good idea. If you really intend for the logging to be present in release mode, you can suppress this warning with a @SuppressLint annotation for the intentional logging calls.;https://googlesamples.github.io/android-custom-lint-rules/checks/LogConditional.md.html;Wrap log statements in a check for BuildConfig.DEBUG to ensure logging is only active in debug builds and automatically removed from release builds.;*.java, *.kt;
WearableBindListener;Yes;;;;✅;;;;;;;✅;BIND_LISTENER receives all Android Wear events whether the application needs them or not. This can be inefficient and cause applications to wake up unnecessarily. With Google Play Services 8.2.0 or later it is recommended to use a more efficient combination of manifest listeners and api-based live listeners filtered by action, path and/or path prefix.;https://googlesamples.github.io/android-custom-lint-rules/checks/WearableBindListener.md.html;For Android Wear apps, avoid using the BIND_LISTENER unless necessary, as it can cause inefficiency by waking the app unnecessarily. Use manifest listeners and API-based live listeners instead.;*.xml;
UsableSpace;Yes;;;;✅;;;;;;;✅;When you need to allocate disk space for large files, consider using the new allocateBytes(FileDescriptor, long) API, which will automatically clear cached files belonging to other apps (as needed) to meet your request. When deciding if the device has enough disk space to hold your new data, call getAllocatableBytes(UUID) instead of using getUsableSpace(), since the former will consider any cached data that the system is willing to clear on your behalf.Note that these methods require API level 26. If your app is running on older devices, you will probably need to use both APIs, conditionally switching on Build.VERSION.SDK_INT. Lint only looks in the same compilation unit to see if you are already using both APIs, so if it warns even though you are already using the new API, consider moving the calls to the same file or suppressing the warning.;https://googlesamples.github.io/android-custom-lint-rules/checks/UsableSpace.md.html;When allocating disk space for large files, use allocateBytes(FileDescriptor, long) (API level 26+) to clear other app’s cached files if needed. Use getAllocatableBytes(UUID) for checking space availability instead of getUsableSpace().;*.java, *.kt;
VectorPath;Yes;;;;✅;;;;;;;✅;Using long vector paths is bad for performance. There are several ways to make the pathData shorter:Using less precision, Removing some minor details, Using the Android Studio vector conversion tool, Rasterizing the image (converting to PNG);https://googlesamples.github.io/android-custom-lint-rules/checks/VectorPath.md.html;void using long vector paths as they negatively affect performance. You can reduce path data by: Reducing precision, Removing minor details, Using Android Studio's vector conversion tool, Rasterizing the image to PNG (if vector paths are not necessary).;*.java, *.kt, *.xml;
UnusedNamespace;Yes;;;;✅;;;;;;;✅;Unused namespace declarations take up space and require processing that is not necessary.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedNamespace.md.html; Remove unused namespace declarations from your XML files as they take up unnecessary space and require additional processing.;*.java, *.kt, *.xml;
RedundantNamespace;Yes;;;;✅;;;;;;;✅;In Android XML documents, only specify the namespace on the root/document element. Namespace declarations elsewhere in the document are typically accidental leftovers from copy/pasting XML from other files or documentation.;https://googlesamples.github.io/android-custom-lint-rules/checks/RedundantNamespace.md.html; Only specify the namespace on the root element of your XML document. Other redundant namespace declarations are typically accidental leftovers from copying/pasting XML code.;*.xml;
ViewTag (obsolete);Yes;;;;✅;;;;;;;✅;Prior to Android 4.0, the implementation of View.setTag(int, Object) would store the objects in a static map, where the values were strongly referenced. This means that if the object contains any references pointing back to the context, the context (which points to pretty much everything else) will leak. If you pass a view, the view provides a reference to the context that created it. Similarly, view holders typically contain a view, and cursors are sometimes also associated with views.;;Avoid using View.setTag(int, Object) before Android 4.0 as it could cause memory leaks due to static map references. This can result in the context being leaked if the tag holds a reference back to the context.;*.java, *.kt;
TooManyViews;Yes;;;;✅;;;;;;;✅;Using too many views in a single layout is bad for performance. Consider using compound drawables or other tricks for reducing the number of views in this layout.The maximum view count defaults to 80 but can be configured with the environment variable ANDROID_LINT_MAX_VIEW_COUNT.;https://googlesamples.github.io/android-custom-lint-rules/checks/TooManyViews.md.html;Limit the number of views in a single layout. Too many views degrade performance. Consider combining elements using compound drawables or optimizing your layout structure. Example: If you have too many views, try using CompoundDrawables or a flatter layout.;*.xml;
TooDeepLayout;Yes;;;;✅;;;;;;;✅;Layouts with too much nesting is bad for performance. Consider using a flatter layout (such as RelativeLayout or GridLayout).The default maximum depth is 10 but can be configured with the environment variable ANDROID_LINT_MAX_DEPTH.;https://googlesamples.github.io/android-custom-lint-rules/checks/TooDeepLayout.md.html;Excessively nested layouts impact performance. Consider flattening the layout structure or using more efficient layouts like RelativeLayout or GridLayout.Example: If your layout has more than 10 nested views, consider restructuring it for better performance.;*.xml;
UseCompoundDrawables;Yes;;;;✅;;;;;;;✅;A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable (a single TextView, using the drawableTop, drawableLeft, drawableRight and/or drawableBottom attributes to draw one or more images adjacent to the text).;https://googlesamples.github.io/android-custom-lint-rules/checks/UseCompoundDrawables.md.html;Combine ImageView and TextView using drawableLeft, drawableTop, drawableRight, or drawableBottom attributes to improve performance instead of adding multiple views.;*.xml;
UseOfBundledGooglePlayServices;Yes;;;;✅;;;;;;;✅;Google Play services SDK's can be selectively included, which enables a smaller APK size. Consider declaring dependencies on individual Google Play services SDK's. If you are using Firebase API's(https://firebase.google.com/docs/android/setup), Android Studio's Tools → Firebase assistant window can automatically add just the dependencies needed for each feature.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseOfBundledGooglePlayServices.md.html;;*.gradle;
StringFormatTrivial;Yes;;;;✅;;;;;;;✅;Every call to String.format creates a new Formatter instance, which will decrease the performance of your app. String.format should only be used when necessary—if the formatted string contains only trivial conversions (e.g. b, s, c) and there are no translation concerns, it will be more efficient to replace them and concatenate with +.;https://googlesamples.github.io/android-custom-lint-rules/checks/StringFormatTrivial.md.html;void using String.format for trivial string formatting as it creates a new Formatter instance, which reduces performance. Instead, concatenate strings where no translation is needed.;*.java, *.kt;
AssertionSideEffect;Yes;;;;✅;;;;;;;✅;There's a lint quickfix to perform this conversion in the Eclipse plugin.;https://googlesamples.github.io/android-custom-lint-rules/checks/AssertionSideEffect.md.html;Make sure assertions do not have side effects in your code as they could cause unnecessary computation in release builds. This could lead to wasted work.;*.java, *.kt;
DuplicateStrings;Yes;;;;✅;;;;;;;✅;Duplicate strings can make applications larger unnecessarily. This lint check looks for duplicate strings, including differences for strings where the only difference is in capitalization. Title casing and all uppercase can all be adjusted in the layout or in code.;https://googlesamples.github.io/android-custom-lint-rules/checks/DuplicateStrings.md.html;duplicate strings (including those differing only by case). These increase the size of the application unnecessarily.;*.xml;
ExpensiveAssertion;Yes;;;;✅;;;;;;;✅;In Kotlin, assertions are not handled the same way as from the Java programming language. In particular, they're just implemented as a library call, and inside the library call the error is only thrown if assertions are enabled.This means that the arguments to the assert call will always be evaluated. If you're doing any computation in the expression being asserted, that computation will unconditionally be performed whether or not assertions are turned on. This typically turns into wasted work in release builds. This check looks for cases where the assertion condition is nontrivial, e.g. it is performing method calls or doing more work than simple comparisons on local variables or fields.;https://googlesamples.github.io/android-custom-lint-rules/checks/ExpensiveAssertion.md.html;n Kotlin, assertions are implemented as library calls, meaning computations in the assert statement are always evaluated regardless of whether assertions are enabled. Avoid performing expensive computations within assertions.;*.java, *.kt;
LaunchActivityFromNotification;Yes;;;;✅;;;;;;;✅;Notifications should only launch activities — that's what users expect (and has been the guidance in both the Android SDK and Material Design documentation for a while).;https://googlesamples.github.io/android-custom-lint-rules/checks/LaunchActivityFromNotification.md.html;Notifications should launch activities, as that is what users expect. Avoid launching services or other components from notifications.;*.java, *.kt;
NotificationTrampoline;Yes;;;;✅;;;;;;;✅;A Service or a BroadcastReceiver should not be used as an intermediate, because this can lead to significant performance problems, and as a result, this will not be allowed in Android 12.;https://googlesamples.github.io/android-custom-lint-rules/checks/NotificationTrampoline.md.html;Avoid using a Service or BroadcastReceiver as an intermediary for launching activities from notifications, as this can cause performance issues. This behavior will be disallowed starting from Android 12.;*.java, *.kt;
AutoboxingStateCreation;Yes;;;;✅;;;;;;;✅;Calling mutableStateOf<t>() when T is either backed by a primitive type on the JVM or is a value class results in a state implementation that requires all state values to be boxed. This usually causes an additional allocation for each state write, and adds some additional work to auto-unbox values when reading the value of the state. Instead, prefer to use a specialized primitive state implementation for Int, Long, Float, and Double when the state does not need to track null values and does not override the default SnapshotMutationPolicy. See mutableIntStateOf(), mutableLongStateOf(), mutableFloatStateOf(), and mutableDoubleStateOf() for more information.;https://googlesamples.github.io/android-custom-lint-rules/checks/AutoboxingStateCreation.md.html;Use mutableIntStateOf(), mutableLongStateOf(), etc. instead of mutableStateOf() for primitives.;*.java, *.kt;
AutoboxingStateValueProperty;;;;;✅;;;;;;;✅;Avoid using the generic value property when using a specialized State type. Reading or writing to the state's generic value property will result in an unnecessary autoboxing operation. Prefer the specialized value property (e.g. intValue for MutableIntState), or use property delegation to avoid unnecessary allocations.;https://googlesamples.github.io/android-custom-lint-rules/checks/AutoboxingStateValueProperty.md.html;Use .intValue, .longValue, etc., instead of .value when using specialized state types.;*.java, *.kt;
FrequentlyChangedStateReadInComposition;;;;;✅;;;;;;;✅;This property is observable and is updated after every scroll or remeasure. If you use it in the composable function directly, it will be recomposed on every change, causing potential performance issues including infinity recomposition loops. Prefer wrapping it with derivedStateOf to use calculation based on this property in composition or collect changes inside LaunchedEffect instead.;https://googlesamples.github.io/android-custom-lint-rules/checks/FrequentlyChangedStateReadInComposition.md.html;Wrap frequently updated state in derivedStateOf to reduce recompositions.;*.java, *.kt;
KaptUsageInsteadOfKsp;;;;;✅;;;;;;;✅;KSP is a more efficient replacement for kapt. For libraries that support both, KSP should be used to improve build times.;https://googlesamples.github.io/android-custom-lint-rules/checks/KaptUsageInsteadOfKsp.md.html;Switch to KSP for annotation processing if supported.;*.gradle;
NotifyDataSetChanged;;;;;✅;;;;;;;✅;The RecyclerView adapter's onNotifyDataSetChanged method does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views.;https://googlesamples.github.io/android-custom-lint-rules/checks/NotifyDataSetChanged.md.html;Use specific update methods (notifyItemInserted(), notifyItemRemoved()) or DiffUtil;*.java, *.kt;
UnnecessaryArrayInit;;;;;✅;;;;;;;✅;When constructing an array in Kotlin, you don't need to pass a lambda to set the initial value if it's identical to the default or if you're going to overwrite all the values without reading them anyway.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnnecessaryArrayInit.md.html;don't  explicitly inititialize an array with zeroed values if not needed. Example: val startPoints = remember { IntArray(4) { 0 } };*.java, *.kt;
UseOfNonLambdaOffsetOverload;;;;;✅;;;;;;;✅;Modifier.offset() is recommended to be used with static arguments only to avoid unnecessary recompositions. Modifier.offset{ } is preferred in the cases where the arguments are backed by a State.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseOfNonLambdaOffsetOverload.md.html;Use Modifier.offset {} instead of Modifier.offset(x, y) for state-backed offsets.;*.java, *.kt;
;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;
;71;;;;;;;;;;;;;;;;